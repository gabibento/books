import express from 'express'; //node.js framework to create and manage http servers
import cors from 'cors'; //Cross-Origin Resource Sharing
import axios from 'axios'; //library that makes HTTP requests to servers
import admin from 'firebase-admin'; //interact with Firebase from server environment to perform actions
import { v4 as uuidv4 } from 'uuid'; //generates unique identifiers (UUIDs)
import serviceAccount from './book-9f561-firebase-adminsdk-g717f-44346011bc.json' assert { type: 'json' }; //imports the JSON file with the Firebase Admin SDK credentials

const app = express();
//Defines the port on which the server will run
const port = process.env.PORT || 5000;

//Enables CORS to allow requests from different sources
app.use(cors());
//Configures the server to understand and process the body of HTTP requests in JSON format
app.use(express.json());

//Initializes the Firebase Admin SDK with credentials and configures the storage bucket 
admin.initializeApp({
  credential: admin.credential.cert(serviceAccount),
  storageBucket: 'book-9f561.appspot.com',
})

//Gets a reference to the Firebase storage bucket, which is used to upload and access files.
const bucket = admin.storage().bucket();

//Sets a POST route to /upload. When this route is called, the code inside the block is executed.
app.post('/upload', async (req, res) => {
  try {
    //Gets the URL of the image sent in the request body
    const imageUrl = req.body.imageUrl;
    //Makes an HTTP GET request to the image URL and gets the image as a binary buffer.
    const response = await axios.get(imageUrl, { responseType: 'arraybuffer' });

    //Converts image data to a binary buffer.
    const buffer = Buffer.from(response.data, 'binary');
    //Creates a reference to a new file in the bucket with a unique name generated by the UUID
    const blob = bucket.file(`images/${uuidv4()}.jpg`);
    //Creates a write stream for the file in the bucket, setting the content type to JPEG.
    const blobStream = blob.createWriteStream({
      metadata: {
        contentType: 'image/jpeg',
      },
    });

    //Configures an error handler for the write stream. If an error occurs during upload, sends a 500 error response
    blobStream.on('error', (err) => {
      res.status(500).send('Erro ao fazer upload da imagem. ' + err);
    });

    //Configures a handler for the write stream completion event. When the upload finishes, it gets the file's public URL and sends that URL back in the response
    blobStream.on('finish', async () => {
      const [publicUrl] = await blob.getSignedUrl({
        action: 'read',
        expires: '03-01-2500',
      });
      res.status(200).send({ imageUrl: publicUrl });
    });

    //Finalizes the writing stream, sending the image buffer to Firebase Storage
    blobStream.end(buffer);
  } catch (error) {
    res.status(500).send('Erro ao buscar ou armazenar a imagem.');
  }
});
//Sets a GET route to the root to confirm that the server is up and running
app.get('/', (req, res) => {
  res.send('Servidor estÃ¡ funcionando!');
});

//Starts the Express server on the defined port and displays a message on the console indicating that the server is running
app.listen(port, () => {
  console.log(`Servidor rodando na porta ${port}`);
});
